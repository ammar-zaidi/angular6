"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const dev_kit_logger_1 = require("../__mocks__/utils/dev-kit-logger");
const engine = __importStar(require("./engine"));
const defaults_1 = require("./defaults");
const exec = __importStar(require("./utils/exec-async"));
const fs = __importStar(require("./utils/fs-async"));
describe('engine', () => {
    let dir;
    let options;
    afterEach(() => {
        jest.clearAllMocks();
    });
    beforeEach(() => {
        jest.spyOn(exec, 'execAsync').mockImplementation(() => Promise.resolve({
            stdout: 'package published',
            stderr: undefined
        }));
    });
    beforeEach(() => {
        dir = 'customDir';
    });
    it('should call NPM Publish with the right options', done => {
        options = {
            access: defaults_1.npmAccess.restricted,
            tag: 'next',
            otp: 'someValue',
            configuration: 'stageConfig',
            dryRun: true
        };
        const optionsOnCMD = `--access ${options.access} --tag ${options.tag} --otp ${options.otp} --dry-run ${options.dryRun}`;
        engine
            .run(dir, options, dev_kit_logger_1.logging)
            .then(() => {
            expect(exec.execAsync).toHaveBeenCalledWith(`npm publish ${dir} ${optionsOnCMD}`);
            done();
        })
            .catch(err => fail('should be completed' + err));
    });
    it('should indicate that an error occurred when there is an error publishing the package', done => {
        const customErr = 'custom err';
        jest
            .spyOn(exec, 'execAsync')
            .mockImplementation(() => Promise.reject(customErr));
        engine
            .run(dir, options, dev_kit_logger_1.logging)
            .then(() => fail('should enter in the catch section'))
            .catch(err => {
            expect(customErr).toEqual(err);
            done();
        });
    });
    describe('Options Management', () => {
        it('should set the default options', done => {
            const options = {};
            const optionsOnCMD = `--access public`;
            engine
                .run(dir, options, dev_kit_logger_1.logging)
                .then(() => {
                expect(exec.execAsync).toHaveBeenCalledWith(`npm publish ${dir} ${optionsOnCMD}`);
                done();
            })
                .catch(err => fail('should be completed' + err));
        });
        it('should overwrite the default option dry-run', done => {
            const options = {
                otp: 'random-text',
                dryRun: true,
                tag: 'random-tag'
            };
            const optionsOnCMD = `--access public --tag ${options.tag} --otp ${options.otp} --dry-run true`;
            engine
                .run(dir, options, dev_kit_logger_1.logging)
                .then(() => {
                expect(exec.execAsync).toHaveBeenCalledWith(`npm publish ${dir} ${optionsOnCMD}`);
                done();
            })
                .catch(err => fail('should be completed' + err));
        });
        it('should overwrite the default option dry-run and access', done => {
            const options = {
                dryRun: true,
                tag: 'random-tag',
                access: defaults_1.npmAccess.restricted
            };
            const optionsOnCMD = `--access ${defaults_1.npmAccess.restricted} --tag ${options.tag} --dry-run true`;
            engine
                .run(dir, options, dev_kit_logger_1.logging)
                .then(() => {
                expect(exec.execAsync).toHaveBeenCalledWith(`npm publish ${dir} ${optionsOnCMD}`);
                done();
            })
                .catch(err => fail('should be completed' + err));
        });
    });
    describe('Package.json Feature', () => {
        let myPackageJSON;
        let expectedPackage;
        let version;
        let options;
        beforeEach(() => {
            jest
                .spyOn(fs, 'readFileAsync')
                .mockImplementation(() => Promise.resolve(JSON.stringify(myPackageJSON)));
            jest
                .spyOn(fs, 'writeFileAsync')
                .mockImplementation(() => Promise.resolve());
        });
        beforeEach(() => {
            version = '1.0.1-next0';
            myPackageJSON = {
                name: 'ngx-deploy-npm',
                version: 'boilerPlate',
                description: 'Publish your angular packages to npm by just run `npm deploy your-packages`',
                main: 'index.js'
            };
            expectedPackage = Object.assign({}, myPackageJSON, { version });
            options = {
                packageVersion: version
            };
        });
        it('should write the version of the sent on the package.json', done => {
            engine
                .run(dir, options, dev_kit_logger_1.logging)
                .then(() => {
                expect(fs.writeFileAsync).toHaveBeenCalledWith(`${dir}/package.json`, JSON.stringify(expectedPackage, null, 4), { encoding: 'utf8' });
                done();
            })
                .catch(err => fail('should be completed' + err));
        });
        it('should not write the version of the sent on the package.json if is on dry-run mode', done => {
            options.dryRun = true;
            engine
                .run(dir, options, dev_kit_logger_1.logging)
                .then(() => {
                expect(fs.writeFileAsync).not.toHaveBeenCalled();
                done();
            })
                .catch(err => fail('should be completed' + err));
        });
        describe('Errors', () => {
            afterEach(() => {
                jest.clearAllMocks();
            });
            it('should throw an error if there is an error reading the package.json', done => {
                const customErr = 'custom err';
                jest
                    .spyOn(fs, 'readFileAsync')
                    .mockImplementation(() => Promise.reject(customErr));
                engine
                    .run(dir, options, dev_kit_logger_1.logging)
                    .then(() => fail('should enter in the catch section'))
                    .catch(err => {
                    expect(customErr).toEqual(err);
                    done();
                });
            });
            it('should throw an error if there is an error writing the package.json', done => {
                const customErr = 'custom err';
                jest
                    .spyOn(fs, 'writeFileAsync')
                    .mockImplementation(() => Promise.reject(customErr));
                engine
                    .run(dir, options, dev_kit_logger_1.logging)
                    .then(() => fail('should enter in the catch section'))
                    .catch(err => {
                    expect(customErr).toEqual(err);
                    done();
                });
            });
        });
    });
});
//# sourceMappingURL=engine.spec.js.map